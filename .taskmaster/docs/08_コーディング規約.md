# コーディング規約

## 概要

Biz Clone のコーディング規約は、**可読性**、**保守性**、**一貫性**を重視し、チーム全体で統一されたコード品質を実現するためのガイドラインです。  
TypeScript、React、Next.js のベストプラクティスに基づいて策定されています。

## 基本原則

### 1. 可読性優先

- **明確な命名**を心がける
- **適切なコメント**を記述する
- **複雑な処理は分割**して理解しやすくする

### 2. 型安全性

- **TypeScript の型システム**を最大限活用
- **any 型の使用を避ける**
- **型ガード**を適切に使用する

### 3. 一貫性

- **ESLint/Prettier** の設定に従う
- **命名規則**を統一する
- **ディレクトリ構造**を遵守する

## 命名規則

### 1. ファイル・ディレクトリ

#### ファイル名

```typescript
// ✅ 良い例
AccountService.ts; // クラスファイル
useAccount.ts; // Hooks
account.types.ts; // 型定義
account.schema.ts; // スキーマ
page.tsx; // Next.js ページ
layout.tsx; // Next.js レイアウト

// ❌ 悪い例
accountservice.ts; // キャメルケースなし
AccountService.tsx; // TypeScript ファイルに tsx
Account_Service.ts; // アンダースコア使用
```

#### ディレクトリ名

```
// ✅ 良い例
components/              // 複数形
lib/services/           // 階層的
app/master/accounts/    // 機能別

// ❌ 悪い例
component/              // 単数形
Services/               // 大文字始まり
master-accounts/        // ハイフン使用
```

### 2. 変数・関数

#### 変数名

```typescript
// ✅ 良い例
const userAccountList = await getAccounts();
const isValidAccount = validateAccount(account);
const totalAmount = calculateTotal(amounts);

// ❌ 悪い例
const list = await getAccounts(); // 不明確
const valid = validateAccount(account); // 短すぎ
const amount = calculateTotal(amounts); // 混同しやすい
```

#### 関数名

```typescript
// ✅ 良い例
function createAccount(data: AccountCreateDto): Promise<Account> {}
function validateAccountCode(code: string): boolean {}
function formatCurrency(amount: number): string {}

// ❌ 悪い例
function account(data: any): any {} // 不明確
function validate(code: string): boolean {} // 範囲不明確
function format(amount: number): string {} // 何をフォーマット？
```

### 3. クラス・インターフェース

#### クラス名

```typescript
// ✅ 良い例
class AccountService {}
class DatabaseConnection {}
class UserAuthenticator {}

// ❌ 悪い例
class accountService {} // 小文字始まり
class Database_Connection {} // アンダースコア
class userAuth {} // 略語
```

#### インターフェース名

```typescript
// ✅ 良い例
interface IAccountRepository {}
interface AccountCreateDto {}
interface UserPermissions {}

// ❌ 悪い例
interface accountRepository {} // 小文字始まり
interface IAccount {} // 単純すぎ
interface Account_Data {} // アンダースコア
```

### 4. 定数・列挙型

#### 定数

```typescript
// ✅ 良い例
const MAX_RETRY_COUNT = 3;
const API_BASE_URL = "https://api.example.com";
const DEFAULT_PAGE_SIZE = 20;

// ❌ 悪い例
const maxRetryCount = 3; // スネークケースでない
const ApiBaseUrl = "https://..."; // キャメルケース
const defaultPageSize = 20; // 定数でない命名
```

#### 列挙型

```typescript
// ✅ 良い例
enum AccountType {
  ASSET = "資産",
  LIABILITY = "負債",
  EQUITY = "資本",
  REVENUE = "収益",
  EXPENSE = "費用",
}

enum HttpStatus {
  OK = 200,
  BAD_REQUEST = 400,
  UNAUTHORIZED = 401,
  NOT_FOUND = 404,
  INTERNAL_SERVER_ERROR = 500,
}

// ❌ 悪い例
enum accountType { // 小文字始まり
  asset = "資産", // 小文字
}
```

## TypeScript 規約

### 1. 型定義

#### 基本的な型定義

```typescript
// ✅ 良い例
interface Account {
  readonly accountCode: string;
  accountName: string;
  accountType: AccountType;
  parentAccountCode: string | null;
  isDetail: boolean;
  isActive: boolean;
  sortOrder: number;
  createdAt: Date;
  updatedAt: Date;
}

// Union Types の適切な使用
type Status = "pending" | "approved" | "rejected";
type SortDirection = "asc" | "desc";

// ❌ 悪い例
interface Account {
  accountCode: any; // any 型は避ける
  accountName?: string; // 必須フィールドをオプションにしない
  type: string; // Union Types を使わない
}
```

#### DTO（Data Transfer Object）

```typescript
// ✅ 良い例
interface AccountCreateDto {
  accountCode: string;
  accountName: string;
  accountType: AccountType;
  parentAccountCode?: string;
  isDetail: boolean;
  isActive?: boolean;
  sortOrder?: number;
}

interface AccountUpdateDto {
  accountName?: string;
  accountType?: AccountType;
  parentAccountCode?: string | null;
  isDetail?: boolean;
  isActive?: boolean;
  sortOrder?: number;
}

// ❌ 悪い例
interface AccountDto {
  [key: string]: any; // インデックスシグネチャの乱用
}
```

### 2. 型ガード

```typescript
// ✅ 良い例
function isAccount(obj: unknown): obj is Account {
  return (
    typeof obj === "object" &&
    obj !== null &&
    "accountCode" in obj &&
    "accountName" in obj &&
    typeof (obj as Account).accountCode === "string" &&
    typeof (obj as Account).accountName === "string"
  );
}

function isValidAccountType(type: string): type is AccountType {
  return Object.values(AccountType).includes(type as AccountType);
}

// ❌ 悪い例
function isAccount(obj: any): boolean {
  // 型ガードでない
  return obj && obj.accountCode;
}
```

### 3. ジェネリクス

```typescript
// ✅ 良い例
interface ApiResponse<T> {
  data: T;
  message: string;
  success: boolean;
}

interface PaginatedResult<T> {
  items: T[];
  totalCount: number;
  page: number;
  pageSize: number;
}

class Repository<T, ID> {
  async findById(id: ID): Promise<T | null> {
    // 実装
  }

  async create(entity: Omit<T, "id" | "createdAt" | "updatedAt">): Promise<T> {
    // 実装
  }
}

// ❌ 悪い例
interface ApiResponse {
  data: any; // ジェネリクスを使わない
  message: string;
  success: boolean;
}
```

## React/Next.js 規約

### 1. コンポーネント定義

#### 関数コンポーネント

```typescript
// ✅ 良い例
interface AccountListProps {
  accounts: Account[];
  onAccountSelect: (account: Account) => void;
  isLoading?: boolean;
}

export function AccountList({
  accounts,
  onAccountSelect,
  isLoading = false,
}: AccountListProps) {
  // Early return pattern
  if (isLoading) {
    return <LoadingSpinner />;
  }

  if (accounts.length === 0) {
    return <EmptyState message="勘定科目が登録されていません" />;
  }

  return (
    <div className="account-list">
      {accounts.map((account) => (
        <AccountCard
          key={account.accountCode}
          account={account}
          onClick={() => onAccountSelect(account)}
        />
      ))}
    </div>
  );
}

// ❌ 悪い例
export function AccountList(props: any) {
  // any 型
  const { accounts, onAccountSelect } = props;

  return (
    <div>
      {accounts &&
        accounts.map(
          (
            account: any,
            index: number // key にindex使用
          ) => (
            <div key={index} onClick={() => onAccountSelect(account)}>
              {account.name}
            </div>
          )
        )}
    </div>
  );
}
```

#### Props の分割代入

```typescript
// ✅ 良い例
interface ButtonProps {
  children: React.ReactNode;
  variant?: "primary" | "secondary" | "danger";
  size?: "small" | "medium" | "large";
  disabled?: boolean;
  onClick?: () => void;
}

export function Button({
  children,
  variant = "primary",
  size = "medium",
  disabled = false,
  onClick,
}: ButtonProps) {
  const className = cn("btn", `btn-${variant}`, `btn-${size}`, {
    "btn-disabled": disabled,
  });

  return (
    <button className={className} disabled={disabled} onClick={onClick}>
      {children}
    </button>
  );
}

// ❌ 悪い例
export function Button(props: ButtonProps) {
  // 分割代入しない
  return (
    <button
      className={`btn btn-${props.variant || "primary"}`} // 複雑なテンプレート
      disabled={props.disabled}
      onClick={props.onClick}
    >
      {props.children}
    </button>
  );
}
```

### 2. カスタムフック

```typescript
// ✅ 良い例
interface UseAccountParams {
  accountCode?: string;
  autoFetch?: boolean;
}

interface UseAccountReturn {
  account: Account | null;
  isLoading: boolean;
  error: Error | null;
  refetch: () => Promise<void>;
  updateAccount: (data: AccountUpdateDto) => Promise<void>;
}

export function useAccount({
  accountCode,
  autoFetch = true,
}: UseAccountParams = {}): UseAccountReturn {
  const [account, setAccount] = useState<Account | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const fetchAccount = useCallback(async () => {
    if (!accountCode) return;

    setIsLoading(true);
    setError(null);

    try {
      const response = await accountService.getAccount(accountCode);
      setAccount(response);
    } catch (err) {
      setError(err instanceof Error ? err : new Error("Unknown error"));
    } finally {
      setIsLoading(false);
    }
  }, [accountCode]);

  const updateAccount = useCallback(
    async (data: AccountUpdateDto) => {
      if (!accountCode) return;

      try {
        const updated = await accountService.updateAccount(accountCode, data);
        setAccount(updated);
      } catch (err) {
        setError(err instanceof Error ? err : new Error("Update failed"));
        throw err;
      }
    },
    [accountCode]
  );

  useEffect(() => {
    if (autoFetch && accountCode) {
      fetchAccount();
    }
  }, [fetchAccount, autoFetch, accountCode]);

  return {
    account,
    isLoading,
    error,
    refetch: fetchAccount,
    updateAccount,
  };
}

// ❌ 悪い例
export function useAccount(accountCode: string) {
  // 型定義不十分
  const [account, setAccount] = useState(null); // null の型指定なし
  const [loading, setLoading] = useState(false); // 命名不一致

  // 依存配列なしの useEffect
  useEffect(() => {
    fetchAccount();
  });

  const fetchAccount = async () => {
    // useCallback なし
    // 実装
  };

  return { account, loading }; // 戻り値の型定義なし
}
```

### 3. Server Actions

```typescript
// ✅ 良い例
"use server";

import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";
import { z } from "zod";

const createAccountSchema = z.object({
  accountCode: z.string().min(3).max(10),
  accountName: z.string().min(1).max(100),
  accountType: z.enum(["資産", "負債", "資本", "収益", "費用"]),
  parentAccountCode: z.string().optional(),
  isDetail: z.boolean(),
});

export async function createAccountAction(formData: FormData) {
  // バリデーション
  const result = createAccountSchema.safeParse({
    accountCode: formData.get("accountCode"),
    accountName: formData.get("accountName"),
    accountType: formData.get("accountType"),
    parentAccountCode: formData.get("parentAccountCode") || undefined,
    isDetail: formData.get("isDetail") === "true",
  });

  if (!result.success) {
    return {
      success: false,
      errors: result.error.flatten().fieldErrors,
    };
  }

  try {
    await accountService.createAccount(result.data);

    // キャッシュ無効化
    revalidatePath("/master/accounts");

    return {
      success: true,
      message: "勘定科目を作成しました",
    };
  } catch (error) {
    console.error("Failed to create account:", error);

    return {
      success: false,
      errors: {
        _form: ["勘定科目の作成に失敗しました"],
      },
    };
  }
}

// ❌ 悪い例
export async function createAccount(data: any) {
  // バリデーションなし
  try {
    // 直接データベース操作
    await prisma.account.create({ data });
    redirect("/accounts");
  } catch (error) {
    throw error; // エラーハンドリング不十分
  }
}
```

## データベース関連規約

### 1. Prisma スキーマ

```prisma
// ✅ 良い例
model Account {
  accountCode       String   @id @db.VarChar(10)
  accountName       String   @db.VarChar(100)
  accountNameKana   String?  @db.VarChar(100)
  accountType       String   @db.VarChar(20)
  parentAccountCode String?  @db.VarChar(10)
  isDetail          Boolean  @default(true)
  isActive          Boolean  @default(true)
  sortOrder         Int      @default(0)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // リレーション
  parentAccount Account?   @relation("AccountHierarchy", fields: [parentAccountCode], references: [accountCode])
  childAccounts Account[] @relation("AccountHierarchy")
  subAccounts   SubAccount[]
  journalDetails JournalDetail[]

  // インデックス
  @@index([accountType])
  @@index([parentAccountCode])
  @@index([isActive, isDetail])
  @@map("accounts")
}

// ❌ 悪い例
model Account {
  id        Int     @id @default(autoincrement())  // 自然キーを使うべき
  code      String                                 // 型指定不十分
  name      String
  type      String
  parent    String?
  detail    Boolean
  active    Boolean
  order     Int
  created   DateTime @default(now())
  updated   DateTime @updatedAt

  @@map("account")  // テーブル名が単数形
}
```

### 2. Repository パターン

```typescript
// ✅ 良い例
export class AccountRepository implements IAccountRepository {
  constructor(private prisma: PrismaClient) {}

  async findById(accountCode: string): Promise<Account | null> {
    try {
      return await this.prisma.account.findUnique({
        where: { accountCode },
        include: {
          parentAccount: true,
          childAccounts: {
            where: { isActive: true },
            orderBy: { sortOrder: "asc" },
          },
          subAccounts: {
            where: { isActive: true },
          },
        },
      });
    } catch (error) {
      this.logger.error("Failed to find account by ID", error, { accountCode });
      throw new RepositoryError("勘定科目の取得に失敗しました", error);
    }
  }

  async create(data: AccountCreateDto): Promise<Account> {
    try {
      return await this.prisma.account.create({
        data: {
          ...data,
          accountCode: data.accountCode.toUpperCase(),
        },
        include: {
          parentAccount: true,
          childAccounts: true,
        },
      });
    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === "P2002") {
          throw new ValidationError("この勘定科目コードは既に使用されています");
        }
      }

      this.logger.error("Failed to create account", error, { data });
      throw new RepositoryError("勘定科目の作成に失敗しました", error);
    }
  }
}

// ❌ 悪い例
export class AccountRepository {
  async findById(id: string) {
    // 戻り値の型なし
    return await prisma.account.findUnique({
      // エラーハンドリングなし
      where: { accountCode: id },
    });
  }

  async create(data: any): Promise<any> {
    // any 型
    return await prisma.account.create({ data }); // バリデーションなし
  }
}
```

## エラーハンドリング

### 1. カスタムエラークラス

```typescript
// ✅ 良い例
export abstract class AppError extends Error {
  abstract readonly statusCode: number;
  abstract readonly isOperational: boolean;

  constructor(
    message: string,
    public readonly context?: Record<string, unknown>
  ) {
    super(message);
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
}

export class ValidationError extends AppError {
  readonly statusCode = 400;
  readonly isOperational = true;

  constructor(
    message: string,
    public readonly field?: string,
    context?: Record<string, unknown>
  ) {
    super(message, context);
  }
}

export class BusinessRuleError extends AppError {
  readonly statusCode = 422;
  readonly isOperational = true;

  constructor(
    message: string,
    public readonly rule: string,
    context?: Record<string, unknown>
  ) {
    super(message, context);
  }
}

export class NotFoundError extends AppError {
  readonly statusCode = 404;
  readonly isOperational = true;
}

// ❌ 悪い例
export class CustomError extends Error {
  // 基底クラスが不十分
  constructor(message: string) {
    super(message);
  }
}

export class ValidationError extends Error {
  // 統一性なし
  statusCode = 400;
}
```

### 2. エラーハンドリングパターン

```typescript
// ✅ 良い例
export async function withErrorHandling<T>(
  operation: () => Promise<T>,
  context?: Record<string, unknown>
): Promise<T> {
  try {
    return await operation();
  } catch (error) {
    if (error instanceof AppError) {
      // アプリケーションエラーはそのまま再スロー
      throw error;
    }

    // 予期しないエラーをログに記録
    logger.error("Unexpected error occurred", error, context);

    // 一般的なエラーに変換
    throw new AppError("システムエラーが発生しました", context);
  }
}

// 使用例
export class AccountService {
  async createAccount(data: AccountCreateDto): Promise<Account> {
    return withErrorHandling(
      async () => {
        // バリデーション
        const validationResult = accountCreateSchema.safeParse(data);
        if (!validationResult.success) {
          throw new ValidationError("入力データが不正です", undefined, {
            errors: validationResult.error.issues,
          });
        }

        // ビジネスルールチェック
        await this.validateBusinessRules(data);

        // 作成実行
        return await this.accountRepository.create(data);
      },
      { operation: "createAccount", data }
    );
  }
}

// ❌ 悪い例
export class AccountService {
  async createAccount(data: any) {
    try {
      return await this.accountRepository.create(data);
    } catch (error) {
      console.log(error); // ログが不十分
      throw new Error("エラーが発生しました"); // 情報が失われる
    }
  }
}
```

## パフォーマンス規約

### 1. React パフォーマンス

```typescript
// ✅ 良い例
interface AccountListProps {
  accounts: Account[];
  onAccountSelect: (account: Account) => void;
}

// memo を使用して不要な再レンダリングを防ぐ
export const AccountList = memo(function AccountList({
  accounts,
  onAccountSelect,
}: AccountListProps) {
  // useMemo で計算量の多い処理をメモ化
  const sortedAccounts = useMemo(() => {
    return accounts.sort((a, b) => a.sortOrder - b.sortOrder);
  }, [accounts]);

  // useCallback でイベントハンドラーをメモ化
  const handleAccountClick = useCallback(
    (account: Account) => {
      onAccountSelect(account);
    },
    [onAccountSelect]
  );

  return (
    <div className="account-list">
      {sortedAccounts.map((account) => (
        <AccountCard
          key={account.accountCode}
          account={account}
          onClick={handleAccountClick}
        />
      ))}
    </div>
  );
});

// ❌ 悪い例
export function AccountList({ accounts, onAccountSelect }: AccountListProps) {
  // 毎回ソート実行（非効率）
  const sortedAccounts = accounts.sort((a, b) => a.sortOrder - b.sortOrder);

  return (
    <div>
      {sortedAccounts.map((account) => (
        <AccountCard
          key={account.accountCode}
          account={account}
          // インライン関数（毎回新しい関数作成）
          onClick={() => onAccountSelect(account)}
        />
      ))}
    </div>
  );
}
```

### 2. データベースパフォーマンス

```typescript
// ✅ 良い例
export class AccountRepository {
  // N+1 問題を避けるための include 使用
  async findAccountsWithChildren(): Promise<Account[]> {
    return await this.prisma.account.findMany({
      where: { isActive: true },
      include: {
        childAccounts: {
          where: { isActive: true },
          orderBy: { sortOrder: "asc" },
        },
        _count: {
          select: { journalDetails: true },
        },
      },
      orderBy: [{ accountType: "asc" }, { sortOrder: "asc" }],
    });
  }

  // ページネーション
  async findPaginated(
    page: number,
    pageSize: number,
    filter?: AccountFilter
  ): Promise<PaginatedResult<Account>> {
    const skip = (page - 1) * pageSize;

    const [accounts, totalCount] = await Promise.all([
      this.prisma.account.findMany({
        skip,
        take: pageSize,
        where: this.buildWhereClause(filter),
        orderBy: { accountCode: "asc" },
      }),
      this.prisma.account.count({
        where: this.buildWhereClause(filter),
      }),
    ]);

    return {
      items: accounts,
      totalCount,
      page,
      pageSize,
      totalPages: Math.ceil(totalCount / pageSize),
    };
  }
}

// ❌ 悪い例
export class AccountRepository {
  // N+1 問題が発生する可能性
  async findAccountsWithChildren(): Promise<Account[]> {
    const accounts = await this.prisma.account.findMany();

    for (const account of accounts) {
      // 各アカウントに対して個別にクエリ実行
      account.children = await this.prisma.account.findMany({
        where: { parentAccountCode: account.accountCode },
      });
    }

    return accounts;
  }

  // 全件取得してアプリケーション側でページング
  async findPaginated(page: number, pageSize: number): Promise<Account[]> {
    const allAccounts = await this.prisma.account.findMany(); // 全件取得
    const start = (page - 1) * pageSize;
    return allAccounts.slice(start, start + pageSize);
  }
}
```

## テスト規約

### 1. 単体テスト

```typescript
// ✅ 良い例
describe("AccountService", () => {
  let accountService: AccountService;
  let mockRepository: jest.Mocked<IAccountRepository>;

  beforeEach(() => {
    mockRepository = createMockRepository();
    accountService = new AccountService(mockRepository);
  });

  describe("createAccount", () => {
    const validAccountData: AccountCreateDto = {
      accountCode: "TEST001",
      accountName: "テスト勘定科目",
      accountType: "資産",
      isDetail: true,
      isActive: true,
      sortOrder: 1,
    };

    it("正常な勘定科目データで作成できること", async () => {
      // Arrange
      const expectedAccount = { ...validAccountData, id: 1 } as Account;
      mockRepository.create.mockResolvedValue(expectedAccount);

      // Act
      const result = await accountService.createAccount(validAccountData);

      // Assert
      expect(mockRepository.create).toHaveBeenCalledWith(validAccountData);
      expect(result).toEqual(expectedAccount);
    });

    it("重複する勘定科目コードでエラーになること", async () => {
      // Arrange
      mockRepository.create.mockRejectedValue(
        new ValidationError("この勘定科目コードは既に使用されています")
      );

      // Act & Assert
      await expect(
        accountService.createAccount(validAccountData)
      ).rejects.toThrow(ValidationError);
    });

    it.each([
      ["", "勘定科目コードは必須です"],
      ["A", "勘定科目コードは3文字以上で入力してください"],
      ["ABCDEFGHIJK", "勘定科目コードは10文字以下で入力してください"],
      ["test@123", "勘定科目コードは英数字で入力してください"],
    ])(
      '無効な勘定科目コード "%s" でエラーになること',
      async (invalidCode, expectedMessage) => {
        // Arrange
        const invalidData = { ...validAccountData, accountCode: invalidCode };

        // Act & Assert
        await expect(accountService.createAccount(invalidData)).rejects.toThrow(
          expectedMessage
        );
      }
    );
  });
});

// ❌ 悪い例
describe("AccountService", () => {
  it("works", async () => {
    // テスト名が不明確
    const service = new AccountService();
    const result = await service.createAccount({
      code: "TEST",
      name: "Test",
    });
    expect(result).toBeTruthy(); // アサーションが曖昧
  });
});
```

### 2. 統合テスト

```typescript
// ✅ 良い例
describe("Account API Integration", () => {
  let testDb: PrismaClient;
  let app: NextApp;

  beforeAll(async () => {
    testDb = createTestDatabase();
    app = createTestApp();
    await testDb.$connect();
  });

  afterAll(async () => {
    await testDb.$disconnect();
  });

  beforeEach(async () => {
    await cleanupDatabase(testDb);
    await seedTestData(testDb);
  });

  describe("POST /api/accounts", () => {
    it("勘定科目を作成して201を返すこと", async () => {
      // Arrange
      const accountData = {
        accountCode: "TEST001",
        accountName: "テスト勘定科目",
        accountType: "資産",
        isDetail: true,
        isActive: true,
        sortOrder: 1,
      };

      // Act
      const response = await request(app)
        .post("/api/accounts")
        .send(accountData)
        .expect(201);

      // Assert
      expect(response.body).toMatchObject({
        accountCode: "TEST001",
        accountName: "テスト勘定科目",
        accountType: "資産",
      });

      // データベースに保存されていることを確認
      const savedAccount = await testDb.account.findUnique({
        where: { accountCode: "TEST001" },
      });
      expect(savedAccount).toBeTruthy();
      expect(savedAccount?.accountName).toBe("テスト勘定科目");
    });

    it("重複する勘定科目コードで409を返すこと", async () => {
      // Arrange - 既存データを作成
      await testDb.account.create({
        data: {
          accountCode: "EXISTING",
          accountName: "既存勘定科目",
          accountType: "資産",
          isDetail: true,
          isActive: true,
          sortOrder: 1,
        },
      });

      const duplicateData = {
        accountCode: "EXISTING",
        accountName: "重複勘定科目",
        accountType: "負債",
        isDetail: true,
        isActive: true,
        sortOrder: 2,
      };

      // Act & Assert
      const response = await request(app)
        .post("/api/accounts")
        .send(duplicateData)
        .expect(409);

      expect(response.body.error).toContain("既に使用されています");
    });
  });
});

// ❌ 悪い例
describe("API Test", () => {
  it("creates account", async () => {
    // テスト名が不明確
    const response = await request(app)
      .post("/api/accounts")
      .send({ code: "TEST" }) // 不完全なデータ
      .expect(200); // ステータスコードが間違い

    expect(response.body).toBeTruthy(); // アサーションが不十分
  });
});
```

## コメント・ドキュメント規約

### 1. JSDoc コメント

````typescript
// ✅ 良い例
/**
 * 勘定科目サービス
 * 勘定科目の CRUD 操作とビジネスロジックを提供します
 */
export class AccountService implements IAccountService {
  /**
   * 新しい勘定科目を作成します
   *
   * @param accountData - 作成する勘定科目のデータ
   * @returns 作成された勘定科目
   * @throws {ValidationError} 入力データが不正な場合
   * @throws {BusinessRuleError} ビジネスルールに違反する場合
   *
   * @example
   * ```typescript
   * const account = await accountService.createAccount({
   *   accountCode: 'CASH001',
   *   accountName: '現金',
   *   accountType: '資産',
   *   isDetail: true,
   *   isActive: true,
   *   sortOrder: 1,
   * });
   * ```
   */
  async createAccount(accountData: AccountCreateDto): Promise<Account> {
    // 実装
  }

  /**
   * 勘定科目の階層構造を取得します
   *
   * @param includeInactive - 無効な勘定科目も含めるかどうか（デフォルト: false）
   * @returns 階層構造の勘定科目リスト
   */
  async getAccountHierarchy(
    includeInactive = false
  ): Promise<AccountHierarchyNode[]> {
    // 実装
  }
}

// ❌ 悪い例
// アカウント作成
export class AccountService {
  // アカウント作成する
  async createAccount(data: any): Promise<any> {
    // 型情報なし、説明不十分
    // 実装
  }
}
````

### 2. インラインコメント

```typescript
// ✅ 良い例
export class AccountService {
  async createAccount(accountData: AccountCreateDto): Promise<Account> {
    // 1. 入力データのバリデーション
    const validationResult = accountCreateSchema.safeParse(accountData);
    if (!validationResult.success) {
      throw new ValidationError("入力データが不正です");
    }

    // 2. ビジネスルールの検証
    // 勘定科目コードの重複チェック
    const existingAccount = await this.accountRepository.findById(
      accountData.accountCode
    );
    if (existingAccount) {
      throw new BusinessRuleError(
        "この勘定科目コードは既に使用されています",
        "DUPLICATE_ACCOUNT_CODE"
      );
    }

    // 親科目の存在確認（指定されている場合）
    if (accountData.parentAccountCode) {
      const parentAccount = await this.accountRepository.findById(
        accountData.parentAccountCode
      );
      if (!parentAccount) {
        throw new ValidationError("指定された親科目が存在しません");
      }

      // 親科目が明細科目でないことを確認
      if (parentAccount.isDetail) {
        throw new BusinessRuleError(
          "明細科目を親科目として設定することはできません",
          "INVALID_PARENT_ACCOUNT"
        );
      }
    }

    // 3. データベースに保存
    try {
      return await this.accountRepository.create({
        ...accountData,
        // 勘定科目コードは大文字に統一
        accountCode: accountData.accountCode.toUpperCase(),
      });
    } catch (error) {
      // データベースエラーをアプリケーションエラーに変換
      throw new RepositoryError("勘定科目の作成に失敗しました", error);
    }
  }
}

// ❌ 悪い例
export class AccountService {
  async createAccount(accountData: AccountCreateDto): Promise<Account> {
    // バリデーション
    if (!accountData.accountCode) {
      // 何をバリデーションしているか不明
      throw new Error("error");
    }

    // 保存
    return await this.repo.create(accountData); // 処理の詳細が不明
  }
}
```

### 3. README・ドキュメント

````markdown
<!-- ✅ 良い例 -->

# AccountService

勘定科目の管理を行うサービスクラスです。

## 概要

AccountService は会計システムの勘定科目に関する以下の機能を提供します：

- 勘定科目の CRUD 操作
- 階層構造の管理
- ビジネスルールの検証
- 検索・フィルタリング

## 使用方法

### 勘定科目の作成

```typescript
import { AccountService } from "@/lib/services/AccountService";

const accountService = new AccountService(accountRepository);

const account = await accountService.createAccount({
  accountCode: "CASH001",
  accountName: "現金",
  accountType: "資産",
  isDetail: true,
  isActive: true,
  sortOrder: 1,
});
```
````

### 階層構造の取得

```typescript
const hierarchy = await accountService.getAccountHierarchy();
```

## API リファレンス

### `createAccount(accountData: AccountCreateDto): Promise<Account>`

新しい勘定科目を作成します。

**パラメータ:**

- `accountData`: 作成する勘定科目のデータ

**戻り値:**

- `Promise<Account>`: 作成された勘定科目

**例外:**

- `ValidationError`: 入力データが不正な場合
- `BusinessRuleError`: ビジネスルールに違反する場合

## ビジネスルール

1. 勘定科目コードは 3-10 文字の英数字である必要があります
2. 勘定科目コードは一意である必要があります
3. 親科目は明細科目ではない必要があります
4. 階層の深さは 3 レベルまでです

<!-- ❌ 悪い例 -->

# AccountService

勘定科目のサービス

## 使い方

アカウントを作成できます。

```typescript
const service = new AccountService();
const account = await service.create(data);
```

````

## 設定ファイル

### 1. ESLint 設定

```javascript
// eslint.config.mjs
export default [
  {
    files: ['**/*.{js,jsx,ts,tsx}'],
    languageOptions: {
      parser: '@typescript-eslint/parser',
      parserOptions: {
        ecmaVersion: 'latest',
        sourceType: 'module',
        ecmaFeatures: {
          jsx: true,
        },
      },
    },
    plugins: {
      '@typescript-eslint': require('@typescript-eslint/eslint-plugin'),
      'react': require('eslint-plugin-react'),
      'react-hooks': require('eslint-plugin-react-hooks'),
    },
    rules: {
      // TypeScript 関連
      '@typescript-eslint/no-unused-vars': 'error',
      '@typescript-eslint/explicit-function-return-type': 'warn',
      '@typescript-eslint/no-explicit-any': 'error',
      '@typescript-eslint/prefer-const': 'error',

      // React 関連
      'react/prop-types': 'off',
      'react/react-in-jsx-scope': 'off',
      'react-hooks/rules-of-hooks': 'error',
      'react-hooks/exhaustive-deps': 'warn',

      // 一般的なルール
      'prefer-const': 'error',
      'no-var': 'error',
      'object-shorthand': 'error',
      'prefer-template': 'error',
    },
  },
  {
    files: ['**/__tests__/**', '**/*.test.{js,jsx,ts,tsx}'],
    rules: {
      '@typescript-eslint/explicit-function-return-type': 'off',
    },
  },
];
````

### 2. Prettier 設定

```json
// .prettierrc
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false,
  "bracketSpacing": true,
  "arrowParens": "avoid",
  "endOfLine": "lf",
  "jsxSingleQuote": true,
  "quoteProps": "as-needed"
}
```

### 3. TypeScript 設定

```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["DOM", "DOM.Iterable", "ES2022"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"]
    },
    // 厳格な型チェック
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "exactOptionalPropertyTypes": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules", "dist", ".next"]
}
```

このコーディング規約に従うことで、チーム全体で一貫性のある高品質なコードを維持できます。定期的な見直しと更新により、プロジェクトの成長とともに規約も進化させていきます。
